float swap(float& a,float& b){
    int temp=a;
    a=b;
    b=temp;
    return 0;
}

double swap(double a,double b){
    double temp=a;
    a=b;
    b=temp;
    return 0;}

/*此处函数重载会报错，是因为函数签名相同，（函数签名：函数名+参数类型+参数个数）而与返回值类型无关。*/

/*“Swap2”无法达到预期效果，是因为“Swap2”中仅仅发生了值的传递（实参的值传递到了形参中）这是单向传递。
 比喻：现有两个实参盒子，两个形参盒子。实盒中的值备份到形盒中，而形参互相交换关实参什么事。*/

/*“Swap1”可以达到预期效果，是因为“Swap1”中发生了引用传递（引用传递的本质是给变量起了一个别名，引用传递的实参必须是变量）这是双向传递。
 比喻：现有两个实参盒子，通过引用它有了形参盒子的别名，那么形参的交换实际上就是实参的交换。*/

/*见解:目前我遇到的函数很少对实参产生影响，但对例外来说就要使用引用传递了*/

/*声明一个引用，必须同时对他初始化，但形参仅在函数被调用时被分配储存空间，在此之前没有空间存储初始值，造成了引用的例外*/